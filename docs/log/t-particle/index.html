<!doctype>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=yes">
<meta name="keywords" content="">
<meta name="description" content="CLASS">
<title>t - particle</title>
<style>
html,body{height:100%;overflow:hidden;}
body{
	margin: 0;
	padding: 0;
	background: #000;
	color: #FFF;
	font-size: 12px;
	font-family: Arial;
}
#container{
	width: 100%;
	height: 100%;
}

h1,p{
	margin: 0;
	padding: 0;
	line-height: 1;
	position: fixed;
	z-index: 100;
	font-size: 1em;
}
h1{
	left: 32px;
	top: 32px;
}
p{
	left: 32px;
	bottom: 32px;
}
</style>
</head>
<body>
<h1>t - particle</h1>
<div id="container"></div>
<p>&copy; nulldesign.jp</p>
<script src="../shared/js/jquery/jquery-2.1.3.min.js"></script>
<script src="../shared/js/gist304522-8f481c980fe34e6930d44c61c59d7851f4235a3c/perlin-noise-simplex.js"></script>
<script src="../shared/js/three/r70/three.min.js"></script>
<script src="world3d.js"></script>

<script type="x-shader/x-vertex" id="vertexshader">
uniform float scale;
uniform float size;
void main()
{
	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
	gl_PointSize = size * scale;
	//gl_PointSize = size * scale * length( normalize( mvPosition.xyz ) );
	//gl_PointSize = size * ( 1000.0 / length( mvPosition.xyz ) ) * scale;
	gl_Position += projectionMatrix * mvPosition;
}
</script>
<script type="x-shader/x-fragment" id="fragmentshader">
uniform vec3 color;
uniform sampler2D texture;
void main()
{
	gl_FragColor = vec4( color, 1.0 );
	gl_FragColor *= gl_FragColor * texture2D( texture, gl_PointCoord );
}
</script>

<script type="text/javascript">
(function(){
	var _tr = 0x66 / 0xFF;
	var _tg = 0x99 / 0xFF;
	var _tb = 0xCC / 0xFF;
	var __r = _tr;
	var __g = _tg;
	var __b = _tb;
	var _size = 400;
	var _hsize = _size * 0.5;
	var lineNums = 1024 * 64;
	var lineLenght = 24;
	var _initSpeed = 2.0;
	var _speed = 0.24;
	var _scale = 1.6;
	var _frection = 0.96;
	var _is3d = true;
	var _changeDuration = 8.0;
	var simplexNoiseX = new SimplexNoise();
	var simplexNoiseY = new SimplexNoise();
	var simplexNoiseZ = new SimplexNoise();
	var _cube;
	var _lineMaterial;
	var _lineList = [];
	var _particle;
	var _wheelValue = 1200;
	var _particleAccell = 0.01;

	//	threejs
	var _dom = document.getElementById('container');
	var _t = new world3d.three( _dom );
	_t.camera.position.set( 0, 0, _wheelValue );

	//
	_cube = new THREE.Object3D();
	_t.scene.add( _cube );

	//	init lines

	init();
	start();

	function displaywheel( e )
	{
		var evt = window.event || e //equalize event object
		var delta = evt.detail? evt.detail*(-120) : evt.wheelDelta;
		delta = Math.floor( delta / 12 );

		_wheelValue += delta;
		_wheelValue = _wheelValue<250?250:_wheelValue>1500?1500:_wheelValue;
	}
 
var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel";
if (document.attachEvent)
{
	document.attachEvent("on"+mousewheelevt, displaywheel)
}
else if (document.addEventListener)
{
	document.addEventListener(mousewheelevt, displaywheel, false)
}

	//	FUNCTION
	function init()
	{
		var _material = new THREE.PointCloudMaterial({
			size: 100,
			color: new THREE.Color(__r,__g,__b),
			transparent:true,
			opacity:0.6,
			blending:THREE.AdditiveBlending,
			map: new THREE.ImageUtils.loadTexture( "spark1.png" )
		});
		world3d.uniforms.color = { type: "c", value: new THREE.Color(__r,__g,__b) };
		world3d.uniforms.texture = { type: "t", value: THREE.ImageUtils.loadTexture( "spark1.png" ) };
		world3d.uniforms.scale = { type: "f", value: 1.0 }
		world3d.uniforms.size = { type: "f", value: 10.0 }

		world3d.uniforms.scale.value = ( world3d.uniforms.resolution.value.x * world3d.uniforms.resolution.value.y ) / ( 1280 * 800) * 0.75;
		$( window ).on('resize', function(e){

			world3d.uniforms.scale.value = ( world3d.uniforms.resolution.value.x * world3d.uniforms.resolution.value.y ) / ( 1280 * 800) * 0.75;
		})

		var _shaderMaterial = new THREE.ShaderMaterial( {
			uniforms:       world3d.uniforms,
			//attributes:     world3d.attributes,
			vertexShader:   document.getElementById( 'vertexshader' ).textContent,
			fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
			blending:       THREE.AdditiveBlending,
			depthTest:      false,
			transparent:    true
		});

		_lineMaterial = _material;
		_lineMaterial = _shaderMaterial;

		var _geometry = new THREE.Geometry();
		for( var i = 0; i < lineNums; i++ )
		{
			_geometry.vertices[i] = new THREE.Vector3( Math.random()*10-5,Math.random()*10-5,Math.random()*10-5 );
			var _vx = Math.random() * 2 - 1;
			var _vy = Math.random() * 2 - 1;
			var _vz = Math.random() * 2 - 1;
			_vx *= _initSpeed;
			_vy *= _initSpeed;
			_vz *= _initSpeed;

			_lineList.push({
				vertices:_geometry.vertices[i],
				vx: _vx,
				vy: _vy,
				vz: _vz
			});
		}

		_particle = new THREE.PointCloud( _geometry, _shaderMaterial );
		_cube.add( _particle )

		lineBox();

	}
	function lineBox()
	{
		var _material = new THREE.LineBasicMaterial({linewidth:1,color: 0xFFFFFF,transparent:true,opacity: 0.6});
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,_hsize,_hsize );
		_geometry.vertices[2] = new THREE.Vector3( -_hsize,_hsize,-_hsize );
		_geometry.vertices[3] = new THREE.Vector3( _hsize,_hsize,-_hsize );
		_geometry.vertices[4] = new THREE.Vector3( _hsize,_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,_hsize );
		_geometry.vertices[2] = new THREE.Vector3( -_hsize,-_hsize,-_hsize );
		_geometry.vertices[3] = new THREE.Vector3( _hsize,-_hsize,-_hsize );
		_geometry.vertices[4] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( _hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( -_hsize,_hsize,_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( -_hsize,_hsize,-_hsize );
		_geometry.vertices[1] = new THREE.Vector3( -_hsize,-_hsize,-_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
		
		var _geometry = new THREE.Geometry();
		_geometry.vertices[0] = new THREE.Vector3( _hsize,_hsize,-_hsize );
		_geometry.vertices[1] = new THREE.Vector3( _hsize,-_hsize,-_hsize );
		var _mesh = new THREE.Line( _geometry, _material );
		_cube.add( _mesh );
	}

	function start()
	{
		setInterval(function(){
			simplexNoiseX = new SimplexNoise();
			simplexNoiseY = new SimplexNoise();
			simplexNoiseZ = new SimplexNoise();

			_tr = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;
			_tg = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;
			_tb = Math.floor( Math.random() * 0xCC + 0x33 ) / 0xFF;

			_particleAccell = Math.random() * 0.01 + 0.01;
		},1000 * _changeDuration);
		setInterval(function(){

			__r += ( _tr - __r ) * 0.01;
			__g += ( _tg - __g ) * 0.01;
			__b += ( _tb - __b ) * 0.01;

			//_lineMaterial.color = new THREE.Color( __r,__g,__b );

			world3d.uniforms.color.value = new THREE.Color( __r,__g,__b );

			//	CUBE
			_cube.rotation.x = world3d.time * 0.0036;
			_cube.rotation.y = world3d.time * 0.0024;

			//	CAMERA
			var _x = world3d.mouse.x / world3d.resolution.x - 0.5;
			var _y = world3d.mouse.y / world3d.resolution.y - 0.5;
			_x *= - world3d.resolution.x * 2.0;
			_y *= world3d.resolution.y * 2.0;
			_t.camera.position.x += ( _x - _t.camera.position.x ) * 0.2;
			_t.camera.position.y += ( _y - _t.camera.position.y ) * 0.2;
			_t.camera.position.z += ( _wheelValue - _t.camera.position.z ) * 0.2;



			_t.camera.lookAt( world3d.ZERO );

			//	LINE
			var len = _lineList.length;
			while( len )
			{
				len--;
				var _obj = _lineList[len];
				var _vertices = _obj.vertices;
				var _px = _vertices.x;
				var _py = _vertices.y;
				var _pz = _vertices.z;

				_vertices.x += _obj.vx;
				_vertices.y += _obj.vy;
				_vertices.z += _obj.vz;

				_obj.vx += simplexNoiseX.noise( ( _vertices.z + _hsize ) / _size * _scale, ( _vertices.y + _hsize ) / _size * _scale ) * _speed;
				_obj.vy += simplexNoiseY.noise( ( _vertices.x + _hsize ) / _size * _scale, ( _vertices.z + _hsize ) / _size * _scale ) * _speed;
				_obj.vz += simplexNoiseZ.noise( ( _vertices.y + _hsize ) / _size * _scale, ( _vertices.x + _hsize ) / _size * _scale ) * _speed;

				//	air frection
				_obj.vx *= _frection;
				_obj.vy *= _frection;
				_obj.vz *= _frection;

				//	pseudo grav
				_vertices.x += ( 0 - _vertices.x ) * _particleAccell;
				_vertices.y += ( 0 - _vertices.y ) * _particleAccell;
				_vertices.z += ( 0 - _vertices.z ) * _particleAccell;

				//
				if( _vertices.x < -_hsize )
				{
					_vertices.x = -_hsize;
					_obj.vx *= - 1;

				} else if( _vertices.x > _hsize )
				{
					_vertices.x = _hsize;
					_obj.vx *= - 1;
				}
				if( _vertices.y < -_hsize )
				{
					_vertices.y = -_hsize;
					_obj.vy *= - 1;
				} else if( _vertices.y > _hsize )
				{
					_vertices.y = _hsize;
					_obj.vy *= - 1;
				}
				if( _vertices.z < -_hsize )
				{
					_vertices.z = -_hsize;
					_obj.vz *= - 1;
				} else if( _vertices.z > _hsize )
				{
					_vertices.z = _hsize;
					_obj.vz *= - 1;
				}
			}

			_particle.geometry.verticesNeedUpdate = true;
		},1000/60);
	}

	function createPlane()
	{
		var _geometry = new THREE.PlaneGeometry( _size, _size, 1, 1 );
		var _material = new THREE.MeshPhongMaterial({side:THREE.DoubleSide,transparent:true,opacity: 0.6});
		var _mesh = new THREE.Mesh( _geometry, _material );
		return _mesh;
	}

})();
</script>
</body>
</html>
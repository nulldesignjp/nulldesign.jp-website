/*	js.js*/$(function(){	(function($){		var _data = [];		var _files = [			'spring-of-life-01.bvh',			'spring-of-life-02.bvh',			'spring-of-life-03.bvh'		];				var ua =		{			'msie'	:	false,			'msie6'	:	false,			'msie7'	:	false,			'msie8'	:	false,			'msie9'	:	false,			'iphone'	:	false,			'ipad'	:	false,			'ipod'	:	false,			'safari'	:	false,			'firefox'	:	false,			'chrome'	:	false,			'opera'	:	false,			'android'	:	false,			'blackberry'	:	false		};		var _ua = navigator.userAgent.toLowerCase();		_ua = _ua.replace(/ /g, "");				for( var i in ua )		{			if( _ua.indexOf( i ) != -1 )			{				ua[i] = true;			}		}				var _frameCount = 0;				var _colorList = [			0xCC0000,			0x00CC00,			0x0000CC		];				var isWebGlEnabeld = Detector.webgl;		var renderer;		var container;		var scene;		var camera;		var light;		var light2;		var plane;		var _audio;				//	canvas check and load bvh file.		var _canvas = document.createElement( 'CANVAS' );		if( !_canvas || !_canvas.getContext )		{			var _p = document.createElement( 'p' );			_p.classname = 'noCanvas';			$( _p ).text('CANVASに対応したブラウザが必要なコンテンツです。');			$( '#container').append( _p );			return;		} else {			_load();		}				function _load()		{			var _url = _files.pop();			$.ajax({				url:	_url,				success	:	function( bvh )				{					var lineList = bvh.split(/[\r\n]+/);					for( var index in lineList )					{						lineList[index] = rstrip( lineList[index] );					}										_data.push( lineList );										if( _files.length != 0 )					{						_load();					} else {						_parse();					}				}			});		}				function _parse()		{			var len = _data.length;			for( var i = 0; i < len; i++ )			{				var _list = _data[i];				var len2 = _list.length;				var _type = '';								_data[i] = {};				_data[i].offset = [];				_data[i].motion = [];				_data[i].points = [];				_data[i].cube = [];								var len2 = _list.length;				for( var j = 0; j < len2; j++ )				{					if( inc( _list[j], 'ROOT' ) || inc( _list[j], 'JOINT' ) )					{						var _obj = {};						_data[i].offset.push( _obj );						var _joints = _list[j].split(' ');						_obj.joint = _joints[1];					}										if( inc( _list[j], 'OFFSET' ) )					{						var _offsets = _list[j].split( ' ' );						_offsets.shift();						var len3 = _offsets.length;						for( var k = 0; k < len3; k++ )						{							_offsets[k] = Number( _offsets[k] );						}						_obj.offset = _offsets;					}										if( _type == 'MOTION' )					{						var _motions = _list[j].split(' ');						var len3 = _motions.length;						for( var k = 0; k < len3; k++ )						{							_motions[k] = Number( _motions[k] );						}						_data[i].motion.push( _motions );					}										if( inc( _list[j], 'MOTION' ) )					{						_type = 'MOTION';					}				}				_data[i].motion.shift();				_data[i].motion.shift();			}						console.log( _data );			_createTree();			//_start();		}				function inc( e, s )		{			return ( e.indexOf( s ) != -1 )? true	:	false;		}				function rstrip(s){		    return s.replace(/^\s+/,"");		}				function rotate( _x, _y, _degree )		{			var _rad = _degree * Math.PI / 180;			var _sin = Math.sin( _rad );			var _cos = Math.cos( _rad );			var __x = _x;			var __y = _y;			__x = _cos * _x - _sin * _y;			__y = _sin * _x + _cos * _y;			return {a: __x,b:__y};		}				function _onresize( e )		{			camera.aspect = container.clientWidth / container.clientHeight;			camera.updateProjectionMatrix();			renderer.setSize( container.clientWidth, container.clientHeight );		}				function _createTree()		{			//	default setting			container = document.getElementById('container');			scene = new THREE.Scene();						camera = new THREE.PerspectiveCamera( 45, container.clientWidth / container.clientHeight, 1, 10000 );			camera.position.set( 0, 500, 1000 );			camera.lookAt( {x:0, y:200, z:0 } );			scene.add( camera );						light = new THREE.DirectionalLight( 0xFFFFFF, 1 );			light.position.set( 0, 200, -1000 ).normalize();			scene.add( light );						light2 = new THREE.DirectionalLight( 0xFFFFFF, 1 );			light2.position.set( 0, 400, 1000 ).normalize();			scene.add( light2 );									//	renderer			if( isWebGlEnabeld )			{				renderer = new THREE.WebGLRenderer( { antialias: true, clearColor: 0x000000 } );			} else {				renderer = new THREE.CanvasRenderer();			}			renderer.setSize( container.clientWidth, container.clientHeight );			container.appendChild( renderer.domElement );						//	test						plane = new THREE.Mesh( new THREE.PlaneGeometry( 1600, 1600, 16, 16 ), new THREE.MeshBasicMaterial( { color: 0x666666, wireframe: true } ) );			plane.rotation.x = - 90 * ( Math.PI / 180 );			scene.add( plane );					    	len = _data.length;	    	for( var i = 0; i < len; i++ )	    	{	    		var _color = _colorList.pop();	    		var len2 = _data[i].offset.length;		    	for( var j = 0; j < len2; j++ )		    	{		    		var _r = 10;		    		_r = ( j == 0 )? 20:_r;		    		_r = ( j == 2 )? 5:_r;		    		_r = ( j == 4 )? 24:_r;		    		_r = ( j == 6 )? 36:_r;		    		_r = ( j == 7 )? 6:_r;		    		_r = ( j == 10 )? 20:_r;		    		_r = ( j == 11 )? 6:_r;		    		_r = ( j == 14 )? 20:_r;		    		_r = ( j == 17 )? 20:_r;		    		_r = ( j == 21 )? 20:_r;		    		var _geometry = new THREE.SphereGeometry( _r, 6, 4 );		    		var _material = new THREE.MeshLambertMaterial( { color: _color, shading: THREE.FlatShading, overdraw: true } );		    		var _sphere = new THREE.Mesh( _geometry, _material );		    		_data[i].points.push( _sphere );		    		scene.add( _sphere );		    	}	    	}						_audio = document.createElement('audio');			$( window ).bind( 'resize', _onresize );			animate();			if( ua.iphone || ua.msie || ua.firefox || ua.ipad )			{				_start();			} else {				$( '#container' ).append( _audio );				$( _audio ).append('<source src="Perfume_globalsite_sound.mp3" type="audio/mp3"><source src="Perfume_globalsite_sound.ogg" type="audio/ogg"><source src="Perfume_globalsite_sound.wav" type="audio/wav">');				_audio.volume = .1;				_audio.addEventListener('canplaythrough', function ()				{					_audio.play();					_start();			   }, false);			}		}				function _start()		{			var _fps = 1000 / 40;			setInterval( function(){	_loop();	}, _fps );		}				function _loop()		{			var _ctx = _canvas.getContext('2d');			_ctx.clearRect( 0, 0, 960, 480 );						var _scale = 2;				var len = _data.length;			for( var i = 0; i < len; i++ )			{				//	xyzのオフセット座標				var _ox = _data[i].motion[_frameCount][0] * _scale;				var _oy = _data[i].motion[_frameCount][1] * _scale;				var _oz = _data[i].motion[_frameCount][2] * _scale;								var _offset = {						x	:	_ox,						y	:	_oy,						z	:	_oz,						rx	:	180,						ry	:	180,						rz	:	180				};				var _stock = {};								/*					各jointにアプローチ				*/				var len2 = _data[i].offset.length;				for( var j = 0; j < len2; j++ )				{					var _pData = _data[i].offset[j];					var _motions = _data[i].motion;					var _joint = _pData.joint;					var _offsets = _pData.offset;										//	腕、足は基準点を引っ張りだす							if( _joint == 'RightHip' || _joint == 'LeftHip' )							{								_offset.x = _stock['Hips'].x;								_offset.y = _stock['Hips'].y;								_offset.z = _stock['Hips'].z;								_offset.rx = _stock['Hips'].rx;								_offset.ry = _stock['Hips'].ry;								_offset.rz = _stock['Hips'].rz;							} else if( _joint == 'RightCollar' || _joint == 'LeftCollar' )							{								_offset.x = _stock['Chest4'].x;								_offset.y = _stock['Chest4'].y;								_offset.z = _stock['Chest4'].z;								_offset.rx = _stock['Chest4'].rx;								_offset.ry = _stock['Chest4'].ry;								_offset.rz = _stock['Chest4'].rz;							}																				//	アフィン変換					var _x = _offsets[0] * _scale;					var _y = _offsets[1] * _scale;					var _z = _offsets[2] * _scale;										var _obj = rotate( _x, _y, _offset.rz );					_x = _obj.a;					_y = _obj.b;					var _obj = rotate( _y, _z, _offset.rx );					_y = _obj.a;					_z = _obj.b;					var _obj = rotate( _z, _x, _offset.ry );					_z = _obj.a;					_x = _obj.b;										//	座標の更新					_x = _x + _offset.x;					_y = _y + _offset.y;					_z = _z + _offset.z;										//	記録用のオブジェクトに値を格納					_offset.x = _x;					_offset.y = _y;					_offset.z = _z;										//	角度情報を更新					_offset.rx -= _motions[ _frameCount ][ j * 3 + 3 + 1 ];					_offset.ry += _motions[ _frameCount ][ j * 3 + 3 + 0 ];					_offset.rz += _motions[ _frameCount ][ j * 3 + 3 + 2 ];										/*						ここで描画する					*/					_data[i].points[j].position.x = _x;					_data[i].points[j].position.y = _y;					_data[i].points[j].position.z = _z;					_data[i].points[j].rotation.x = _offset.rx * Math.PI / 180;					_data[i].points[j].rotation.y = _offset.ry * Math.PI / 180;					_data[i].points[j].rotation.z = _offset.rz * Math.PI / 180;										//	データをストックする					_stock[_joint] = {						x	:	_offset.x,						y	:	_offset.y,						z	:	_offset.z,						rx	:	_offset.rx,						ry	:	_offset.ry,						rz	:	_offset.rz					};				}			}						_frameCount++;			_frameCount %= 2800;						if( _frameCount == 0 )			{				_audio.play(0)			}					}				function animate()		{			requestAnimationFrame( animate );			render();		}				function render()		{				//	camera motion				var _cos = Math.cos( - .005 );				var _sin = Math.sin( - .005 );				var _x = camera.position.x;				var _z = camera.position.z;				camera.position.x = _x * _cos - _z * _sin;				camera.position.z = _x * _sin + _z * _cos;				camera.position.y = Math.sin( _frameCount * .01 ) * 300 + 500;				camera.lookAt( {x:0, y:200, z:0 } );			renderer.render( scene, camera );		}	})(jQuery);});
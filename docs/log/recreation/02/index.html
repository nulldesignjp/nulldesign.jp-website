<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0">
<meta name="description" content="notall, Phisics, reverse">
<meta name="keywords" content="">
<title>webgl</title>
<style>
html,body{height: 100%;overflow: hidden;}
body{margin: 0; padding: 0; background: #000;}
h1{position: fixed;left: 64px;top:48px;margin: 0;padding: 0;color: #FFF;font-family:Arial;font-weight: normal;font-size:18px;}
h1 span{font-weight: bold;}
</style>
</head>
<body>
<div id="container"></div>
<h1 id="siteID">re:<span>block</span></h1>
<script type="text/javascript" src="cannon.min.js"></script>
<script type="text/javascript" src="three.min.js"></script>
<script type="text/javascript" src="HorizontalTiltShiftShader.js"></script>
<script type="text/javascript" src="VerticalTiltShiftShader.js"></script>
<script type="text/javascript" src="EffectComposer.js"></script>
<script type="text/javascript" src="MaskPass.js"></script>
<script type="text/javascript" src="RenderPass.js"></script>
<script type="text/javascript" src="ShaderPass.js"></script>
<script type="text/javascript" src="CopyShader.js"></script>
<script type="text/javascript" src="OrbitControls.js"></script>
<script type="text/javascript">

(function(){

	var scene, camera, renderer, focus, lights, controls, composer;
	var meshlist, bodylist, world;
	var _flag,_positions,_breakMode;
	var _breakCount, __breakCount;
	_flag = true;
	_breakCount = 600;
	__breakCount = 0;
	_breakMode = true;

	window.onload = function(){

		var width = window.innerWidth;
		var height = window.innerHeight;

		scene = new THREE.Scene();
		scene.fog = new THREE.Fog( 0x080808, 2400, 3200 );

		focus = new THREE.Vector3();

		camera = new THREE.PerspectiveCamera( 45, width / height, 0.1, 3200 );
		camera.position.set(0, 0, 1000);
		camera.lookAt( focus );

		lights = [];
		lights[0] = new THREE.AmbientLight( 0xC80808 );
		scene.add( lights[0] );

		lights[1] = new THREE.DirectionalLight( 0xCCCCCC );
		lights[1].position.set( 3000, 3000, 3000 );
		scene.add( lights[1] );

		lights[2] = new THREE.PointLight( 0xCCCCCC, 1, 1000 );
		lights[2].position.set( 500, 500, 500 );
		scene.add( lights[2] );

		lights[3] = new THREE.PointLight( 0xCCCCCC, 0.5, 600 );
		lights[3].position.set( -500, 250, -500 );
		scene.add( lights[3] );

		lights[2].castShadow = true;
		lights[3].castShadow = true;


		renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
		renderer.setClearColor(0x000000);
		renderer.setSize( width, height );
		document.getElementById('container').appendChild(renderer.domElement);

		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		composer = new THREE.EffectComposer( renderer );

		var renderPass = new THREE.RenderPass( scene, camera );
		renderPass.enabled = true;
		renderPass.renderToScreen = false;
		composer.addPass( renderPass );

		var _shaderPass = new THREE.ShaderPass( THREE.HorizontalTiltShiftShader );
		_shaderPass.enabled = true;
		_shaderPass.renderToScreen = false;
		composer.addPass( _shaderPass );

		var _shaderPass = new THREE.ShaderPass( THREE.VerticalTiltShiftShader );
		_shaderPass.enabled = true;
		_shaderPass.renderToScreen = false;
		composer.addPass( _shaderPass );

		var MonoShader = {
			uniforms: {
				"tDiffuse": { type:"t", value: null }
			},
			vertexShader: [
				"varying vec2 vUv;",
				"void main() {",
					"vUv = uv;",
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
				"}"
			].join( "\n" ),

			fragmentShader: [
					"uniform sampler2D tDiffuse;",
					"varying vec2 vUv;",
					"const float redScale   = 0.298912;",
					"const float greenScale = 0.586611;",
					"const float blueScale  = 0.114478;",
					"const vec3  monochromeScale = vec3(redScale, greenScale, blueScale);",
				"void main() {",
					"vec4 smpColor = texture2D(tDiffuse, vUv);",
					"float grayColor = dot(smpColor.rgb, monochromeScale);",
					"smpColor = vec4(vec3(grayColor), 1.0);",
					"gl_FragColor = smpColor;",
				"}"

			].join( "\n" )

		};
		var _shaderPass = new THREE.ShaderPass( MonoShader );
		_shaderPass.enabled = true;
		_shaderPass.renderToScreen = false;
		composer.addPass( _shaderPass );

		var _copySahder = new THREE.ShaderPass( THREE.CopyShader );
		_copySahder.renderToScreen = true;
		composer.addPass( _copySahder );

		controls = new THREE.OrbitControls( camera, renderer.domElement );

		var _geometry = new THREE.PlaneGeometry( 12800, 12800, 10, 10 );
		_geometry.rotateX( - Math.PI * 0.5 );
		var _material = new THREE.MeshPhongMaterial();
		ground = new THREE.Mesh( _geometry, _material );
		scene.add( ground );

		ground.receiveShadow = true;

		meshlist = [];
		bodylist = [];
		_positions = [];

		//	canon
		// Setup our world
            world = new CANNON.World();
            world.quatNormalizeSkip = 0;
            world.quatNormalizeFast = false;

            world.gravity.set(0,-9.8,0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create a plane
            var groundShape = new CANNON.Plane();
            var groundMaterial = new CANNON.Material();
            var groundBody = new CANNON.Body({ mass: 0, material: groundMaterial });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
            world.add(groundBody);


		var _ldr = new THREE.TextureLoader().load('IMG_0077.JPG', function(e){
			_nextStep(e);
		});
		var _imageScale = 0.5;
		function _nextStep( e )
		{
			var grid = 60 * _imageScale;
			var w = Math.floor( width / grid * _imageScale);
			var h = Math.floor( height / grid * _imageScale );
			
				focus.y = ( grid * h ) * 0.5;
				camera.position.y = ( grid * h ) * 0.5;
				camera.position.z = 1200;

			var _pw = 1.0;
			var _ph = 1.0;
			var _w = e.image.width;
			var _h = e.image.height;
			var _wp = w*grid / _w;
			var _hp = h*grid/ _h;
			var _px = _wp / _w;
			var _py = _hp / _h;

			//
			if( _px < _py )
			{
				_pw = _wp / _hp;
				_ph = 1.0;
			} else {
				_pw = 1.0;
				_ph = _hp / _wp;
			}

			if( _pw > 1.0 )
			{
				_ph /= _pw;
				_pw = 1.0;
			}

			if( _ph > 1.0 )
			{
				_pw /= _ph;
				_ph = 1.0;
			}

			var _offsetX = ( 1.0 - _pw ) * 0.5;
			var _offsetY = ( 1.0 - _ph ) * 0.5;

			for( var i = 0; i < h; i++ )
			{
				for( var j = 0; j < w; j++ )
				{
					var _geometry = new THREE.BoxGeometry( grid, grid, grid, 1, 1, 1 );

					for( var k = 0; k < 6; k++ )
					{
						var _x0 = j / w;
						var _y0 = i / h;
						var _x1 = ( j + 1 ) / w;
						var _y1 = ( i + 1 ) / h;

						var _f0 = _geometry.faceVertexUvs[0][ k * 2 + 0 ];
						var _f1 = _geometry.faceVertexUvs[0][ k * 2 + 1 ];

						_f0[0].x = _x0;
						_f0[0].y = _y1;
						_f0[1].x = _x0;
						_f0[1].y = _y0;
						_f0[2].x = _x1;
						_f0[2].y = _y1;

						_f1[0].x = _x0;
						_f1[0].y = _y0;
						_f1[1].x = _x1;
						_f1[1].y = _y0;
						_f1[2].x = _x1;
						_f1[2].y = _y1;
					}

					var _material = new THREE.MeshStandardMaterial({
						map: _ldr,
						roughness: 0.5,
						metalness: 0.5
					});


					_material.map.repeat.set( _pw, _ph );
					_material.map.offset = new THREE.Vector2( 0 + _offsetX, 0 + _offsetY );

					_material.map.minFilter = THREE.LinearFilter;
					_material.map.wrapS = THREE.RepeatWrapping;
					_material.map.wrapT = THREE.RepeatWrapping;

					var _mesh = new THREE.Mesh( _geometry, _material );
					scene.add( _mesh );
					_mesh.castShadow = true;
					_mesh.receiveShadow = true;

					meshlist.push( _mesh );

					// Create boxes
					var _adj = 0.001;
					var boxShape = new CANNON.Box(new CANNON.Vec3( grid * 0.5 * _adj, grid * 0.5 * _adj, grid * 0.5 * _adj ));

					var mat = new CANNON.Material();
					boxBody = new CANNON.Body({ mass: 1.0, material: mat });
					boxBody.angularDamping = 0.01;
					boxBody.addShape(boxShape);
					boxBody.position.set(
						( ( j - w * .5 ) * grid ) * 0.001,
						( ( i - h * .5 ) * grid + ( grid * ( h + 1 ) ) * .5 ) * 0.001,
						0
					);

					boxBody.velocity.set(
						( Math.random() - 0.5 ) * 3.2 * _imageScale,
						( Math.random() - 0.5 ) * 3.2 * _imageScale,
						( Math.random() - 0.5 ) * 3.2 * _imageScale
					);
					boxBody.angularVelocity.set(
						( Math.random() - 0.5 ) * 1.0,
						( Math.random() - 0.5 ) * 1.0,
						( Math.random() - 0.5 ) * 1.0
					);

					boxBody.applyImpulse( new CANNON.Vec3( (Math.random()-.5)*4*_imageScale,(Math.random()-.5)*4*_imageScale,(Math.random()-.5)*4*_imageScale ), new CANNON.Vec3(0,0,(Math.random()-.5)) );

					var matGround = new CANNON.ContactMaterial(groundMaterial, mat, { friction: 0.2, restitution: 0.8 });
					world.addContactMaterial(matGround);


					world.add(boxBody);
					bodylist.push(boxBody);
				}
			}


			// //	break
			_duration = 1200;
			if( _breakMode )
			{
				for( var i = 0; i < _breakCount; i++ )
				{
					_positions[i] = [];

					var len = meshlist.length;
					while( len )
					{
						len --;
						meshlist[len].position.copy(bodylist[len].position);
						meshlist[len].quaternion.copy(bodylist[len].quaternion);

						_positions[i][len] = {
							p: meshlist[len].position.clone().multiplyScalar(1000),
							r: meshlist[len].rotation.clone(),
						}
					}
					world.step( 1 / _duration );

					_duration += ( 60 - _duration ) * 0.05;
				}
			}
		}


		var update = function()
		{
			window.requestAnimationFrame( update );

			controls.update();

			if( _flag && _breakMode && _breakCount > 0 )
			{
				//_breakCount--;

				var len = meshlist.length;
				while( len )
				{
					len --;
					meshlist[len].position.copy( _positions[__breakCount][len].p );
					//meshlist[len].quaternion.copy( _positions[_breakCount][len].r );
					meshlist[len].rotation.copy( _positions[__breakCount][len].r );
				}
			}

			if( !_breakMode )
			{
				world.step( 1 / 60 );
				for(var i=0; i !== meshlist.length; i++){
					meshlist[i].position.copy(bodylist[i].position);
					meshlist[i].quaternion.copy(bodylist[i].quaternion);
				}
			}

			camera.lookAt(focus);
			//renderer.render( scene, camera );
			composer.render( 0.1 );
		};

		var exp = function( camera ){
			var h = window.innerHeight;
			var distance = -( h / 2 ) / Math.tan( ( camera.fov * Math.PI / 180 ) / 2 );
			return distance;
		}

		var resize = function(e){
			var width  = window.innerWidth;
			var height = window.innerHeight;
			renderer.setSize( width, height );
			composer.setSize( width, height );
			if( camera.aspect )
			{
				camera.aspect = width / height;
			} else {
				camera.left = - width * 0.5;
				camera.right = width * 0.5;
				camera.bottom = - height * 0.5;
				camera.top = height * 0.5;
			}
			
			camera.updateProjectionMatrix();

		};

		window.onresize = resize;

		update();


		window.addEventListener( 'click', function(){
			//_flag = !_flag;
		});

		window.addEventListener( 'mousemove', function(e){
			__breakCount = Math.floor( e.pageX / window.innerWidth * _breakCount );
		});
	};
})();

/*
	function getWorldToScreen2D( _mesh )
	{
		var vector = new THREE.Vector3();
		var widthHalf = 0.5 * renderer.context.canvas.width;
		var heightHalf = 0.5 * renderer.context.canvas.height;
		_mesh.updateMatrixWorld();
		vector.setFromMatrixPosition(_mesh.matrixWorld);
		vector.project(this.camera);
		vector.x = ( vector.x * widthHalf ) + widthHalf;
		vector.y = - ( vector.y * heightHalf ) + heightHalf;
		return { 
		    x: vector.x,
		    y: vector.y
		};
	}

	function epx( camera )
	{
		var h = window.innerHeight;
		var distance = -( h / 2 ) / Math.tan( ( camera.fov * Math.PI / 180 ) / 2 );
		return distance;
	}
*/

</script>
</body>
</html>
